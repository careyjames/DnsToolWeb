// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: ice.sql

package dbq

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const iCAECountResultsByProtocol = `-- name: ICAECountResultsByProtocol :many
SELECT protocol, layer,
       COUNT(*) AS total,
       COUNT(*) FILTER (WHERE passed = true) AS passed,
       COUNT(*) FILTER (WHERE passed = false) AS failed
FROM ice_results
WHERE run_id = $1
GROUP BY protocol, layer
ORDER BY protocol, layer
`

type ICAECountResultsByProtocolRow struct {
	Protocol string `db:"protocol" json:"protocol"`
	Layer    string `db:"layer" json:"layer"`
	Total    int64  `db:"total" json:"total"`
	Passed   int64  `db:"passed" json:"passed"`
	Failed   int64  `db:"failed" json:"failed"`
}

func (q *Queries) ICAECountResultsByProtocol(ctx context.Context, runID int32) ([]ICAECountResultsByProtocolRow, error) {
	rows, err := q.db.Query(ctx, iCAECountResultsByProtocol, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICAECountResultsByProtocolRow{}
	for rows.Next() {
		var i ICAECountResultsByProtocolRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.Total,
			&i.Passed,
			&i.Failed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCAEGetAllMaturity = `-- name: ICAEGetAllMaturity :many
SELECT protocol, layer, maturity, total_runs, consecutive_passes,
       first_pass_at, last_regression_at, last_evaluated_at
FROM ice_maturity
ORDER BY protocol, layer
`

type ICAEGetAllMaturityRow struct {
	Protocol          string           `db:"protocol" json:"protocol"`
	Layer             string           `db:"layer" json:"layer"`
	Maturity          string           `db:"maturity" json:"maturity"`
	TotalRuns         int32            `db:"total_runs" json:"total_runs"`
	ConsecutivePasses int32            `db:"consecutive_passes" json:"consecutive_passes"`
	FirstPassAt       pgtype.Timestamp `db:"first_pass_at" json:"first_pass_at"`
	LastRegressionAt  pgtype.Timestamp `db:"last_regression_at" json:"last_regression_at"`
	LastEvaluatedAt   pgtype.Timestamp `db:"last_evaluated_at" json:"last_evaluated_at"`
}

func (q *Queries) ICAEGetAllMaturity(ctx context.Context) ([]ICAEGetAllMaturityRow, error) {
	rows, err := q.db.Query(ctx, iCAEGetAllMaturity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICAEGetAllMaturityRow{}
	for rows.Next() {
		var i ICAEGetAllMaturityRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.Maturity,
			&i.TotalRuns,
			&i.ConsecutivePasses,
			&i.FirstPassAt,
			&i.LastRegressionAt,
			&i.LastEvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCAEGetFailedResultsByRun = `-- name: ICAEGetFailedResultsByRun :many
SELECT protocol, layer, case_id, case_name, expected, actual, rfc_section, notes
FROM ice_results
WHERE run_id = $1 AND passed = false
ORDER BY protocol, layer, case_id
`

type ICAEGetFailedResultsByRunRow struct {
	Protocol   string  `db:"protocol" json:"protocol"`
	Layer      string  `db:"layer" json:"layer"`
	CaseID     string  `db:"case_id" json:"case_id"`
	CaseName   string  `db:"case_name" json:"case_name"`
	Expected   *string `db:"expected" json:"expected"`
	Actual     *string `db:"actual" json:"actual"`
	RfcSection *string `db:"rfc_section" json:"rfc_section"`
	Notes      *string `db:"notes" json:"notes"`
}

func (q *Queries) ICAEGetFailedResultsByRun(ctx context.Context, runID int32) ([]ICAEGetFailedResultsByRunRow, error) {
	rows, err := q.db.Query(ctx, iCAEGetFailedResultsByRun, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICAEGetFailedResultsByRunRow{}
	for rows.Next() {
		var i ICAEGetFailedResultsByRunRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.CaseID,
			&i.CaseName,
			&i.Expected,
			&i.Actual,
			&i.RfcSection,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCAEGetLatestRun = `-- name: ICAEGetLatestRun :one
SELECT id, app_version, git_commit, run_type, total_cases, total_passed, total_failed, duration_ms, created_at
FROM ice_test_runs
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) ICAEGetLatestRun(ctx context.Context) (IceTestRun, error) {
	row := q.db.QueryRow(ctx, iCAEGetLatestRun)
	var i IceTestRun
	err := row.Scan(
		&i.ID,
		&i.AppVersion,
		&i.GitCommit,
		&i.RunType,
		&i.TotalCases,
		&i.TotalPassed,
		&i.TotalFailed,
		&i.DurationMs,
		&i.CreatedAt,
	)
	return i, err
}

const iCAEGetMaturity = `-- name: ICAEGetMaturity :one
SELECT protocol, layer, maturity, total_runs, consecutive_passes,
       first_pass_at, last_regression_at, last_evaluated_at
FROM ice_maturity
WHERE protocol = $1 AND layer = $2
`

type ICAEGetMaturityParams struct {
	Protocol string `db:"protocol" json:"protocol"`
	Layer    string `db:"layer" json:"layer"`
}

type ICAEGetMaturityRow struct {
	Protocol          string           `db:"protocol" json:"protocol"`
	Layer             string           `db:"layer" json:"layer"`
	Maturity          string           `db:"maturity" json:"maturity"`
	TotalRuns         int32            `db:"total_runs" json:"total_runs"`
	ConsecutivePasses int32            `db:"consecutive_passes" json:"consecutive_passes"`
	FirstPassAt       pgtype.Timestamp `db:"first_pass_at" json:"first_pass_at"`
	LastRegressionAt  pgtype.Timestamp `db:"last_regression_at" json:"last_regression_at"`
	LastEvaluatedAt   pgtype.Timestamp `db:"last_evaluated_at" json:"last_evaluated_at"`
}

func (q *Queries) ICAEGetMaturity(ctx context.Context, arg ICAEGetMaturityParams) (ICAEGetMaturityRow, error) {
	row := q.db.QueryRow(ctx, iCAEGetMaturity, arg.Protocol, arg.Layer)
	var i ICAEGetMaturityRow
	err := row.Scan(
		&i.Protocol,
		&i.Layer,
		&i.Maturity,
		&i.TotalRuns,
		&i.ConsecutivePasses,
		&i.FirstPassAt,
		&i.LastRegressionAt,
		&i.LastEvaluatedAt,
	)
	return i, err
}

const iCAEGetRecentRegressions = `-- name: ICAEGetRecentRegressions :many
SELECT protocol, layer, previous_maturity, new_maturity, failed_cases, notes, created_at
FROM ice_regressions
ORDER BY created_at DESC
LIMIT $1
`

type ICAEGetRecentRegressionsRow struct {
	Protocol         string           `db:"protocol" json:"protocol"`
	Layer            string           `db:"layer" json:"layer"`
	PreviousMaturity string           `db:"previous_maturity" json:"previous_maturity"`
	NewMaturity      string           `db:"new_maturity" json:"new_maturity"`
	FailedCases      []string         `db:"failed_cases" json:"failed_cases"`
	Notes            *string          `db:"notes" json:"notes"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) ICAEGetRecentRegressions(ctx context.Context, limit int32) ([]ICAEGetRecentRegressionsRow, error) {
	rows, err := q.db.Query(ctx, iCAEGetRecentRegressions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICAEGetRecentRegressionsRow{}
	for rows.Next() {
		var i ICAEGetRecentRegressionsRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.PreviousMaturity,
			&i.NewMaturity,
			&i.FailedCases,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCAEGetResultsByRun = `-- name: ICAEGetResultsByRun :many
SELECT protocol, layer, case_id, case_name, passed, expected, actual, rfc_section, notes
FROM ice_results
WHERE run_id = $1
ORDER BY protocol, layer, case_id
`

type ICAEGetResultsByRunRow struct {
	Protocol   string  `db:"protocol" json:"protocol"`
	Layer      string  `db:"layer" json:"layer"`
	CaseID     string  `db:"case_id" json:"case_id"`
	CaseName   string  `db:"case_name" json:"case_name"`
	Passed     bool    `db:"passed" json:"passed"`
	Expected   *string `db:"expected" json:"expected"`
	Actual     *string `db:"actual" json:"actual"`
	RfcSection *string `db:"rfc_section" json:"rfc_section"`
	Notes      *string `db:"notes" json:"notes"`
}

func (q *Queries) ICAEGetResultsByRun(ctx context.Context, runID int32) ([]ICAEGetResultsByRunRow, error) {
	rows, err := q.db.Query(ctx, iCAEGetResultsByRun, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICAEGetResultsByRunRow{}
	for rows.Next() {
		var i ICAEGetResultsByRunRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.CaseID,
			&i.CaseName,
			&i.Passed,
			&i.Expected,
			&i.Actual,
			&i.RfcSection,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCAEInsertRegression = `-- name: ICAEInsertRegression :exec
INSERT INTO ice_regressions (protocol, layer, run_id, previous_maturity, new_maturity, failed_cases, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type ICAEInsertRegressionParams struct {
	Protocol         string   `db:"protocol" json:"protocol"`
	Layer            string   `db:"layer" json:"layer"`
	RunID            int32    `db:"run_id" json:"run_id"`
	PreviousMaturity string   `db:"previous_maturity" json:"previous_maturity"`
	NewMaturity      string   `db:"new_maturity" json:"new_maturity"`
	FailedCases      []string `db:"failed_cases" json:"failed_cases"`
	Notes            *string  `db:"notes" json:"notes"`
}

func (q *Queries) ICAEInsertRegression(ctx context.Context, arg ICAEInsertRegressionParams) error {
	_, err := q.db.Exec(ctx, iCAEInsertRegression,
		arg.Protocol,
		arg.Layer,
		arg.RunID,
		arg.PreviousMaturity,
		arg.NewMaturity,
		arg.FailedCases,
		arg.Notes,
	)
	return err
}

const iCAEInsertResult = `-- name: ICAEInsertResult :exec
INSERT INTO ice_results (run_id, protocol, layer, case_id, case_name, passed, expected, actual, rfc_section, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type ICAEInsertResultParams struct {
	RunID      int32   `db:"run_id" json:"run_id"`
	Protocol   string  `db:"protocol" json:"protocol"`
	Layer      string  `db:"layer" json:"layer"`
	CaseID     string  `db:"case_id" json:"case_id"`
	CaseName   string  `db:"case_name" json:"case_name"`
	Passed     bool    `db:"passed" json:"passed"`
	Expected   *string `db:"expected" json:"expected"`
	Actual     *string `db:"actual" json:"actual"`
	RfcSection *string `db:"rfc_section" json:"rfc_section"`
	Notes      *string `db:"notes" json:"notes"`
}

func (q *Queries) ICAEInsertResult(ctx context.Context, arg ICAEInsertResultParams) error {
	_, err := q.db.Exec(ctx, iCAEInsertResult,
		arg.RunID,
		arg.Protocol,
		arg.Layer,
		arg.CaseID,
		arg.CaseName,
		arg.Passed,
		arg.Expected,
		arg.Actual,
		arg.RfcSection,
		arg.Notes,
	)
	return err
}

const iCAEInsertTestRun = `-- name: ICAEInsertTestRun :one
INSERT INTO ice_test_runs (app_version, git_commit, run_type, total_cases, total_passed, total_failed, duration_ms)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, created_at
`

type ICAEInsertTestRunParams struct {
	AppVersion  string `db:"app_version" json:"app_version"`
	GitCommit   string `db:"git_commit" json:"git_commit"`
	RunType     string `db:"run_type" json:"run_type"`
	TotalCases  int32  `db:"total_cases" json:"total_cases"`
	TotalPassed int32  `db:"total_passed" json:"total_passed"`
	TotalFailed int32  `db:"total_failed" json:"total_failed"`
	DurationMs  int32  `db:"duration_ms" json:"duration_ms"`
}

type ICAEInsertTestRunRow struct {
	ID        int32            `db:"id" json:"id"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) ICAEInsertTestRun(ctx context.Context, arg ICAEInsertTestRunParams) (ICAEInsertTestRunRow, error) {
	row := q.db.QueryRow(ctx, iCAEInsertTestRun,
		arg.AppVersion,
		arg.GitCommit,
		arg.RunType,
		arg.TotalCases,
		arg.TotalPassed,
		arg.TotalFailed,
		arg.DurationMs,
	)
	var i ICAEInsertTestRunRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const iCAEUpdateMaturity = `-- name: ICAEUpdateMaturity :exec
UPDATE ice_maturity SET
    maturity = $3,
    total_runs = $4,
    consecutive_passes = $5,
    first_pass_at = $6,
    last_regression_at = $7,
    last_evaluated_at = NOW(),
    updated_at = NOW()
WHERE protocol = $1 AND layer = $2
`

type ICAEUpdateMaturityParams struct {
	Protocol          string           `db:"protocol" json:"protocol"`
	Layer             string           `db:"layer" json:"layer"`
	Maturity          string           `db:"maturity" json:"maturity"`
	TotalRuns         int32            `db:"total_runs" json:"total_runs"`
	ConsecutivePasses int32            `db:"consecutive_passes" json:"consecutive_passes"`
	FirstPassAt       pgtype.Timestamp `db:"first_pass_at" json:"first_pass_at"`
	LastRegressionAt  pgtype.Timestamp `db:"last_regression_at" json:"last_regression_at"`
}

func (q *Queries) ICAEUpdateMaturity(ctx context.Context, arg ICAEUpdateMaturityParams) error {
	_, err := q.db.Exec(ctx, iCAEUpdateMaturity,
		arg.Protocol,
		arg.Layer,
		arg.Maturity,
		arg.TotalRuns,
		arg.ConsecutivePasses,
		arg.FirstPassAt,
		arg.LastRegressionAt,
	)
	return err
}

const iCAEUpsertMaturity = `-- name: ICAEUpsertMaturity :exec
INSERT INTO ice_maturity (protocol, layer, maturity, total_runs, consecutive_passes, first_pass_at, last_regression_at, last_evaluated_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
ON CONFLICT (protocol, layer) DO UPDATE SET
    maturity = $3,
    total_runs = $4,
    consecutive_passes = $5,
    first_pass_at = $6,
    last_regression_at = $7,
    last_evaluated_at = NOW(),
    updated_at = NOW()
`

type ICAEUpsertMaturityParams struct {
	Protocol          string           `db:"protocol" json:"protocol"`
	Layer             string           `db:"layer" json:"layer"`
	Maturity          string           `db:"maturity" json:"maturity"`
	TotalRuns         int32            `db:"total_runs" json:"total_runs"`
	ConsecutivePasses int32            `db:"consecutive_passes" json:"consecutive_passes"`
	FirstPassAt       pgtype.Timestamp `db:"first_pass_at" json:"first_pass_at"`
	LastRegressionAt  pgtype.Timestamp `db:"last_regression_at" json:"last_regression_at"`
}

func (q *Queries) ICAEUpsertMaturity(ctx context.Context, arg ICAEUpsertMaturityParams) error {
	_, err := q.db.Exec(ctx, iCAEUpsertMaturity,
		arg.Protocol,
		arg.Layer,
		arg.Maturity,
		arg.TotalRuns,
		arg.ConsecutivePasses,
		arg.FirstPassAt,
		arg.LastRegressionAt,
	)
	return err
}
