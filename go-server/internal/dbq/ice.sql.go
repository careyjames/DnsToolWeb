// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: ice.sql

package dbq

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const iCECountResultsByProtocol = `-- name: ICECountResultsByProtocol :many
SELECT protocol, layer,
       COUNT(*) AS total,
       COUNT(*) FILTER (WHERE passed = true) AS passed,
       COUNT(*) FILTER (WHERE passed = false) AS failed
FROM ice_results
WHERE run_id = $1
GROUP BY protocol, layer
ORDER BY protocol, layer
`

type ICECountResultsByProtocolRow struct {
	Protocol string `db:"protocol" json:"protocol"`
	Layer    string `db:"layer" json:"layer"`
	Total    int64  `db:"total" json:"total"`
	Passed   int64  `db:"passed" json:"passed"`
	Failed   int64  `db:"failed" json:"failed"`
}

func (q *Queries) ICECountResultsByProtocol(ctx context.Context, runID int32) ([]ICECountResultsByProtocolRow, error) {
	rows, err := q.db.Query(ctx, iCECountResultsByProtocol, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICECountResultsByProtocolRow{}
	for rows.Next() {
		var i ICECountResultsByProtocolRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.Total,
			&i.Passed,
			&i.Failed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCEGetAllMaturity = `-- name: ICEGetAllMaturity :many
SELECT protocol, layer, maturity, total_runs, consecutive_passes,
       first_pass_at, last_regression_at, last_evaluated_at
FROM ice_maturity
ORDER BY protocol, layer
`

type ICEGetAllMaturityRow struct {
	Protocol          string           `db:"protocol" json:"protocol"`
	Layer             string           `db:"layer" json:"layer"`
	Maturity          string           `db:"maturity" json:"maturity"`
	TotalRuns         int32            `db:"total_runs" json:"total_runs"`
	ConsecutivePasses int32            `db:"consecutive_passes" json:"consecutive_passes"`
	FirstPassAt       pgtype.Timestamp `db:"first_pass_at" json:"first_pass_at"`
	LastRegressionAt  pgtype.Timestamp `db:"last_regression_at" json:"last_regression_at"`
	LastEvaluatedAt   pgtype.Timestamp `db:"last_evaluated_at" json:"last_evaluated_at"`
}

func (q *Queries) ICEGetAllMaturity(ctx context.Context) ([]ICEGetAllMaturityRow, error) {
	rows, err := q.db.Query(ctx, iCEGetAllMaturity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICEGetAllMaturityRow{}
	for rows.Next() {
		var i ICEGetAllMaturityRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.Maturity,
			&i.TotalRuns,
			&i.ConsecutivePasses,
			&i.FirstPassAt,
			&i.LastRegressionAt,
			&i.LastEvaluatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCEGetFailedResultsByRun = `-- name: ICEGetFailedResultsByRun :many
SELECT protocol, layer, case_id, case_name, expected, actual, rfc_section, notes
FROM ice_results
WHERE run_id = $1 AND passed = false
ORDER BY protocol, layer, case_id
`

type ICEGetFailedResultsByRunRow struct {
	Protocol   string  `db:"protocol" json:"protocol"`
	Layer      string  `db:"layer" json:"layer"`
	CaseID     string  `db:"case_id" json:"case_id"`
	CaseName   string  `db:"case_name" json:"case_name"`
	Expected   *string `db:"expected" json:"expected"`
	Actual     *string `db:"actual" json:"actual"`
	RfcSection *string `db:"rfc_section" json:"rfc_section"`
	Notes      *string `db:"notes" json:"notes"`
}

func (q *Queries) ICEGetFailedResultsByRun(ctx context.Context, runID int32) ([]ICEGetFailedResultsByRunRow, error) {
	rows, err := q.db.Query(ctx, iCEGetFailedResultsByRun, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICEGetFailedResultsByRunRow{}
	for rows.Next() {
		var i ICEGetFailedResultsByRunRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.CaseID,
			&i.CaseName,
			&i.Expected,
			&i.Actual,
			&i.RfcSection,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCEGetLatestRun = `-- name: ICEGetLatestRun :one
SELECT id, app_version, git_commit, run_type, total_cases, total_passed, total_failed, duration_ms, created_at
FROM ice_test_runs
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) ICEGetLatestRun(ctx context.Context) (IceTestRun, error) {
	row := q.db.QueryRow(ctx, iCEGetLatestRun)
	var i IceTestRun
	err := row.Scan(
		&i.ID,
		&i.AppVersion,
		&i.GitCommit,
		&i.RunType,
		&i.TotalCases,
		&i.TotalPassed,
		&i.TotalFailed,
		&i.DurationMs,
		&i.CreatedAt,
	)
	return i, err
}

const iCEGetMaturity = `-- name: ICEGetMaturity :one
SELECT protocol, layer, maturity, total_runs, consecutive_passes,
       first_pass_at, last_regression_at, last_evaluated_at
FROM ice_maturity
WHERE protocol = $1 AND layer = $2
`

type ICEGetMaturityParams struct {
	Protocol string `db:"protocol" json:"protocol"`
	Layer    string `db:"layer" json:"layer"`
}

type ICEGetMaturityRow struct {
	Protocol          string           `db:"protocol" json:"protocol"`
	Layer             string           `db:"layer" json:"layer"`
	Maturity          string           `db:"maturity" json:"maturity"`
	TotalRuns         int32            `db:"total_runs" json:"total_runs"`
	ConsecutivePasses int32            `db:"consecutive_passes" json:"consecutive_passes"`
	FirstPassAt       pgtype.Timestamp `db:"first_pass_at" json:"first_pass_at"`
	LastRegressionAt  pgtype.Timestamp `db:"last_regression_at" json:"last_regression_at"`
	LastEvaluatedAt   pgtype.Timestamp `db:"last_evaluated_at" json:"last_evaluated_at"`
}

func (q *Queries) ICEGetMaturity(ctx context.Context, arg ICEGetMaturityParams) (ICEGetMaturityRow, error) {
	row := q.db.QueryRow(ctx, iCEGetMaturity, arg.Protocol, arg.Layer)
	var i ICEGetMaturityRow
	err := row.Scan(
		&i.Protocol,
		&i.Layer,
		&i.Maturity,
		&i.TotalRuns,
		&i.ConsecutivePasses,
		&i.FirstPassAt,
		&i.LastRegressionAt,
		&i.LastEvaluatedAt,
	)
	return i, err
}

const iCEGetRecentRegressions = `-- name: ICEGetRecentRegressions :many
SELECT protocol, layer, previous_maturity, new_maturity, failed_cases, notes, created_at
FROM ice_regressions
ORDER BY created_at DESC
LIMIT $1
`

type ICEGetRecentRegressionsRow struct {
	Protocol         string           `db:"protocol" json:"protocol"`
	Layer            string           `db:"layer" json:"layer"`
	PreviousMaturity string           `db:"previous_maturity" json:"previous_maturity"`
	NewMaturity      string           `db:"new_maturity" json:"new_maturity"`
	FailedCases      []string         `db:"failed_cases" json:"failed_cases"`
	Notes            *string          `db:"notes" json:"notes"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) ICEGetRecentRegressions(ctx context.Context, limit int32) ([]ICEGetRecentRegressionsRow, error) {
	rows, err := q.db.Query(ctx, iCEGetRecentRegressions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICEGetRecentRegressionsRow{}
	for rows.Next() {
		var i ICEGetRecentRegressionsRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.PreviousMaturity,
			&i.NewMaturity,
			&i.FailedCases,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCEGetResultsByRun = `-- name: ICEGetResultsByRun :many
SELECT protocol, layer, case_id, case_name, passed, expected, actual, rfc_section, notes
FROM ice_results
WHERE run_id = $1
ORDER BY protocol, layer, case_id
`

type ICEGetResultsByRunRow struct {
	Protocol   string  `db:"protocol" json:"protocol"`
	Layer      string  `db:"layer" json:"layer"`
	CaseID     string  `db:"case_id" json:"case_id"`
	CaseName   string  `db:"case_name" json:"case_name"`
	Passed     bool    `db:"passed" json:"passed"`
	Expected   *string `db:"expected" json:"expected"`
	Actual     *string `db:"actual" json:"actual"`
	RfcSection *string `db:"rfc_section" json:"rfc_section"`
	Notes      *string `db:"notes" json:"notes"`
}

func (q *Queries) ICEGetResultsByRun(ctx context.Context, runID int32) ([]ICEGetResultsByRunRow, error) {
	rows, err := q.db.Query(ctx, iCEGetResultsByRun, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ICEGetResultsByRunRow{}
	for rows.Next() {
		var i ICEGetResultsByRunRow
		if err := rows.Scan(
			&i.Protocol,
			&i.Layer,
			&i.CaseID,
			&i.CaseName,
			&i.Passed,
			&i.Expected,
			&i.Actual,
			&i.RfcSection,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const iCEInsertRegression = `-- name: ICEInsertRegression :exec
INSERT INTO ice_regressions (protocol, layer, run_id, previous_maturity, new_maturity, failed_cases, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type ICEInsertRegressionParams struct {
	Protocol         string   `db:"protocol" json:"protocol"`
	Layer            string   `db:"layer" json:"layer"`
	RunID            int32    `db:"run_id" json:"run_id"`
	PreviousMaturity string   `db:"previous_maturity" json:"previous_maturity"`
	NewMaturity      string   `db:"new_maturity" json:"new_maturity"`
	FailedCases      []string `db:"failed_cases" json:"failed_cases"`
	Notes            *string  `db:"notes" json:"notes"`
}

func (q *Queries) ICEInsertRegression(ctx context.Context, arg ICEInsertRegressionParams) error {
	_, err := q.db.Exec(ctx, iCEInsertRegression,
		arg.Protocol,
		arg.Layer,
		arg.RunID,
		arg.PreviousMaturity,
		arg.NewMaturity,
		arg.FailedCases,
		arg.Notes,
	)
	return err
}

const iCEInsertResult = `-- name: ICEInsertResult :exec
INSERT INTO ice_results (run_id, protocol, layer, case_id, case_name, passed, expected, actual, rfc_section, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type ICEInsertResultParams struct {
	RunID      int32   `db:"run_id" json:"run_id"`
	Protocol   string  `db:"protocol" json:"protocol"`
	Layer      string  `db:"layer" json:"layer"`
	CaseID     string  `db:"case_id" json:"case_id"`
	CaseName   string  `db:"case_name" json:"case_name"`
	Passed     bool    `db:"passed" json:"passed"`
	Expected   *string `db:"expected" json:"expected"`
	Actual     *string `db:"actual" json:"actual"`
	RfcSection *string `db:"rfc_section" json:"rfc_section"`
	Notes      *string `db:"notes" json:"notes"`
}

func (q *Queries) ICEInsertResult(ctx context.Context, arg ICEInsertResultParams) error {
	_, err := q.db.Exec(ctx, iCEInsertResult,
		arg.RunID,
		arg.Protocol,
		arg.Layer,
		arg.CaseID,
		arg.CaseName,
		arg.Passed,
		arg.Expected,
		arg.Actual,
		arg.RfcSection,
		arg.Notes,
	)
	return err
}

const iCEInsertTestRun = `-- name: ICEInsertTestRun :one
INSERT INTO ice_test_runs (app_version, git_commit, run_type, total_cases, total_passed, total_failed, duration_ms)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, created_at
`

type ICEInsertTestRunParams struct {
	AppVersion  string `db:"app_version" json:"app_version"`
	GitCommit   string `db:"git_commit" json:"git_commit"`
	RunType     string `db:"run_type" json:"run_type"`
	TotalCases  int32  `db:"total_cases" json:"total_cases"`
	TotalPassed int32  `db:"total_passed" json:"total_passed"`
	TotalFailed int32  `db:"total_failed" json:"total_failed"`
	DurationMs  int32  `db:"duration_ms" json:"duration_ms"`
}

type ICEInsertTestRunRow struct {
	ID        int32            `db:"id" json:"id"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
}

func (q *Queries) ICEInsertTestRun(ctx context.Context, arg ICEInsertTestRunParams) (ICEInsertTestRunRow, error) {
	row := q.db.QueryRow(ctx, iCEInsertTestRun,
		arg.AppVersion,
		arg.GitCommit,
		arg.RunType,
		arg.TotalCases,
		arg.TotalPassed,
		arg.TotalFailed,
		arg.DurationMs,
	)
	var i ICEInsertTestRunRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const iCEUpdateMaturity = `-- name: ICEUpdateMaturity :exec
UPDATE ice_maturity SET
    maturity = $3,
    total_runs = $4,
    consecutive_passes = $5,
    first_pass_at = $6,
    last_regression_at = $7,
    last_evaluated_at = NOW(),
    updated_at = NOW()
WHERE protocol = $1 AND layer = $2
`

type ICEUpdateMaturityParams struct {
	Protocol          string           `db:"protocol" json:"protocol"`
	Layer             string           `db:"layer" json:"layer"`
	Maturity          string           `db:"maturity" json:"maturity"`
	TotalRuns         int32            `db:"total_runs" json:"total_runs"`
	ConsecutivePasses int32            `db:"consecutive_passes" json:"consecutive_passes"`
	FirstPassAt       pgtype.Timestamp `db:"first_pass_at" json:"first_pass_at"`
	LastRegressionAt  pgtype.Timestamp `db:"last_regression_at" json:"last_regression_at"`
}

func (q *Queries) ICEUpdateMaturity(ctx context.Context, arg ICEUpdateMaturityParams) error {
	_, err := q.db.Exec(ctx, iCEUpdateMaturity,
		arg.Protocol,
		arg.Layer,
		arg.Maturity,
		arg.TotalRuns,
		arg.ConsecutivePasses,
		arg.FirstPassAt,
		arg.LastRegressionAt,
	)
	return err
}

const iCEUpsertMaturity = `-- name: ICEUpsertMaturity :exec
INSERT INTO ice_maturity (protocol, layer, maturity, total_runs, consecutive_passes, first_pass_at, last_regression_at, last_evaluated_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
ON CONFLICT (protocol, layer) DO UPDATE SET
    maturity = $3,
    total_runs = $4,
    consecutive_passes = $5,
    first_pass_at = $6,
    last_regression_at = $7,
    last_evaluated_at = NOW(),
    updated_at = NOW()
`

type ICEUpsertMaturityParams struct {
	Protocol          string           `db:"protocol" json:"protocol"`
	Layer             string           `db:"layer" json:"layer"`
	Maturity          string           `db:"maturity" json:"maturity"`
	TotalRuns         int32            `db:"total_runs" json:"total_runs"`
	ConsecutivePasses int32            `db:"consecutive_passes" json:"consecutive_passes"`
	FirstPassAt       pgtype.Timestamp `db:"first_pass_at" json:"first_pass_at"`
	LastRegressionAt  pgtype.Timestamp `db:"last_regression_at" json:"last_regression_at"`
}

func (q *Queries) ICEUpsertMaturity(ctx context.Context, arg ICEUpsertMaturityParams) error {
	_, err := q.db.Exec(ctx, iCEUpsertMaturity,
		arg.Protocol,
		arg.Layer,
		arg.Maturity,
		arg.TotalRuns,
		arg.ConsecutivePasses,
		arg.FirstPassAt,
		arg.LastRegressionAt,
	)
	return err
}
