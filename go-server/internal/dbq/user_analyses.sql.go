// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: user_analyses.sql

package dbq

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSearchUserAnalyses = `-- name: CountSearchUserAnalyses :one
SELECT COUNT(*) FROM user_analyses ua
JOIN domain_analyses da ON ua.analysis_id = da.id
WHERE ua.user_id = $1
  AND da.analysis_success = TRUE
  AND da.full_results IS NOT NULL
  AND (da.domain ILIKE $2 OR da.ascii_domain ILIKE $2)
`

type CountSearchUserAnalysesParams struct {
	UserID int32  `db:"user_id" json:"user_id"`
	Domain string `db:"domain" json:"domain"`
}

func (q *Queries) CountSearchUserAnalyses(ctx context.Context, arg CountSearchUserAnalysesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSearchUserAnalyses, arg.UserID, arg.Domain)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserAnalyses = `-- name: CountUserAnalyses :one
SELECT COUNT(*) FROM user_analyses ua
JOIN domain_analyses da ON ua.analysis_id = da.id
WHERE ua.user_id = $1
  AND da.analysis_success = TRUE
  AND da.full_results IS NOT NULL
`

func (q *Queries) CountUserAnalyses(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countUserAnalyses, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertUserAnalysis = `-- name: InsertUserAnalysis :exec
INSERT INTO user_analyses (user_id, analysis_id)
VALUES ($1, $2)
ON CONFLICT (user_id, analysis_id) DO NOTHING
`

type InsertUserAnalysisParams struct {
	UserID     int32 `db:"user_id" json:"user_id"`
	AnalysisID int32 `db:"analysis_id" json:"analysis_id"`
}

func (q *Queries) InsertUserAnalysis(ctx context.Context, arg InsertUserAnalysisParams) error {
	_, err := q.db.Exec(ctx, insertUserAnalysis, arg.UserID, arg.AnalysisID)
	return err
}

const listUserAnalyses = `-- name: ListUserAnalyses :many
SELECT da.id, da.domain, da.ascii_domain,
       da.spf_status, da.dmarc_status, da.dkim_status,
       da.analysis_success, da.analysis_duration,
       da.posture_hash, da.created_at, da.full_results
FROM user_analyses ua
JOIN domain_analyses da ON ua.analysis_id = da.id
WHERE ua.user_id = $1
  AND da.analysis_success = TRUE
  AND da.full_results IS NOT NULL
ORDER BY ua.created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserAnalysesParams struct {
	UserID int32 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListUserAnalysesRow struct {
	ID               int32            `db:"id" json:"id"`
	Domain           string           `db:"domain" json:"domain"`
	AsciiDomain      string           `db:"ascii_domain" json:"ascii_domain"`
	SpfStatus        *string          `db:"spf_status" json:"spf_status"`
	DmarcStatus      *string          `db:"dmarc_status" json:"dmarc_status"`
	DkimStatus       *string          `db:"dkim_status" json:"dkim_status"`
	AnalysisSuccess  *bool            `db:"analysis_success" json:"analysis_success"`
	AnalysisDuration *float64         `db:"analysis_duration" json:"analysis_duration"`
	PostureHash      *string          `db:"posture_hash" json:"posture_hash"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	FullResults      json.RawMessage  `db:"full_results" json:"full_results"`
}

func (q *Queries) ListUserAnalyses(ctx context.Context, arg ListUserAnalysesParams) ([]ListUserAnalysesRow, error) {
	rows, err := q.db.Query(ctx, listUserAnalyses, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserAnalysesRow{}
	for rows.Next() {
		var i ListUserAnalysesRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.AsciiDomain,
			&i.SpfStatus,
			&i.DmarcStatus,
			&i.DkimStatus,
			&i.AnalysisSuccess,
			&i.AnalysisDuration,
			&i.PostureHash,
			&i.CreatedAt,
			&i.FullResults,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserUniqueDomains = `-- name: ListUserUniqueDomains :many
SELECT da.domain, COUNT(*) AS scan_count,
       MAX(da.created_at) AS last_scanned
FROM user_analyses ua
JOIN domain_analyses da ON ua.analysis_id = da.id
WHERE ua.user_id = $1
  AND da.analysis_success = TRUE
GROUP BY da.domain
ORDER BY MAX(da.created_at) DESC
LIMIT $2
`

type ListUserUniqueDomainsParams struct {
	UserID int32 `db:"user_id" json:"user_id"`
	Limit  int32 `db:"limit" json:"limit"`
}

type ListUserUniqueDomainsRow struct {
	Domain      string      `db:"domain" json:"domain"`
	ScanCount   int64       `db:"scan_count" json:"scan_count"`
	LastScanned interface{} `db:"last_scanned" json:"last_scanned"`
}

func (q *Queries) ListUserUniqueDomains(ctx context.Context, arg ListUserUniqueDomainsParams) ([]ListUserUniqueDomainsRow, error) {
	rows, err := q.db.Query(ctx, listUserUniqueDomains, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserUniqueDomainsRow{}
	for rows.Next() {
		var i ListUserUniqueDomainsRow
		if err := rows.Scan(&i.Domain, &i.ScanCount, &i.LastScanned); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUserAnalyses = `-- name: SearchUserAnalyses :many
SELECT da.id, da.domain, da.ascii_domain,
       da.spf_status, da.dmarc_status, da.dkim_status,
       da.analysis_success, da.analysis_duration,
       da.posture_hash, da.created_at, da.full_results
FROM user_analyses ua
JOIN domain_analyses da ON ua.analysis_id = da.id
WHERE ua.user_id = $1
  AND da.analysis_success = TRUE
  AND da.full_results IS NOT NULL
  AND (da.domain ILIKE $2 OR da.ascii_domain ILIKE $2)
ORDER BY ua.created_at DESC
LIMIT $3 OFFSET $4
`

type SearchUserAnalysesParams struct {
	UserID int32  `db:"user_id" json:"user_id"`
	Domain string `db:"domain" json:"domain"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

type SearchUserAnalysesRow struct {
	ID               int32            `db:"id" json:"id"`
	Domain           string           `db:"domain" json:"domain"`
	AsciiDomain      string           `db:"ascii_domain" json:"ascii_domain"`
	SpfStatus        *string          `db:"spf_status" json:"spf_status"`
	DmarcStatus      *string          `db:"dmarc_status" json:"dmarc_status"`
	DkimStatus       *string          `db:"dkim_status" json:"dkim_status"`
	AnalysisSuccess  *bool            `db:"analysis_success" json:"analysis_success"`
	AnalysisDuration *float64         `db:"analysis_duration" json:"analysis_duration"`
	PostureHash      *string          `db:"posture_hash" json:"posture_hash"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	FullResults      json.RawMessage  `db:"full_results" json:"full_results"`
}

func (q *Queries) SearchUserAnalyses(ctx context.Context, arg SearchUserAnalysesParams) ([]SearchUserAnalysesRow, error) {
	rows, err := q.db.Query(ctx, searchUserAnalyses,
		arg.UserID,
		arg.Domain,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchUserAnalysesRow{}
	for rows.Next() {
		var i SearchUserAnalysesRow
		if err := rows.Scan(
			&i.ID,
			&i.Domain,
			&i.AsciiDomain,
			&i.SpfStatus,
			&i.DmarcStatus,
			&i.DkimStatus,
			&i.AnalysisSuccess,
			&i.AnalysisDuration,
			&i.PostureHash,
			&i.CreatedAt,
			&i.FullResults,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
