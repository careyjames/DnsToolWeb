// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: analysis_stats.sql

package dbq

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUniqueDomainsByDate = `-- name: CountUniqueDomainsByDate :one
SELECT COUNT(DISTINCT domain) FROM domain_analyses
WHERE created_at::date = $1
`

func (q *Queries) CountUniqueDomainsByDate(ctx context.Context, createdAt pgtype.Timestamp) (int64, error) {
	row := q.db.QueryRow(ctx, countUniqueDomainsByDate, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getStatsByDate = `-- name: GetStatsByDate :one
SELECT id, date, total_analyses, successful_analyses, failed_analyses, unique_domains, avg_analysis_time, created_at, updated_at FROM analysis_stats WHERE date = $1
`

func (q *Queries) GetStatsByDate(ctx context.Context, date pgtype.Date) (AnalysisStat, error) {
	row := q.db.QueryRow(ctx, getStatsByDate, date)
	var i AnalysisStat
	err := row.Scan(
		&i.ID,
		&i.Date,
		&i.TotalAnalyses,
		&i.SuccessfulAnalyses,
		&i.FailedAnalyses,
		&i.UniqueDomains,
		&i.AvgAnalysisTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementDailyStats = `-- name: IncrementDailyStats :exec
UPDATE analysis_stats SET
    total_analyses = COALESCE(total_analyses, 0) + 1,
    successful_analyses = CASE WHEN $2::boolean THEN COALESCE(successful_analyses, 0) + 1 ELSE successful_analyses END,
    failed_analyses = CASE WHEN NOT $2::boolean THEN COALESCE(failed_analyses, 0) + 1 ELSE failed_analyses END,
    avg_analysis_time = CASE
        WHEN COALESCE(total_analyses, 0) = 0 THEN $3::double precision
        ELSE (COALESCE(avg_analysis_time, 0) * COALESCE(total_analyses, 0) + $3::double precision) / (COALESCE(total_analyses, 0) + 1)
    END,
    updated_at = NOW()
WHERE date = $1
`

type IncrementDailyStatsParams struct {
	Date    pgtype.Date `db:"date" json:"date"`
	Column2 bool        `db:"column_2" json:"column_2"`
	Column3 float64     `db:"column_3" json:"column_3"`
}

func (q *Queries) IncrementDailyStats(ctx context.Context, arg IncrementDailyStatsParams) error {
	_, err := q.db.Exec(ctx, incrementDailyStats, arg.Date, arg.Column2, arg.Column3)
	return err
}

const insertDailyStats = `-- name: InsertDailyStats :exec
INSERT INTO analysis_stats (date, total_analyses, successful_analyses, failed_analyses, unique_domains, avg_analysis_time, created_at, updated_at)
VALUES ($1, 1, CASE WHEN $2::boolean THEN 1 ELSE 0 END, CASE WHEN NOT $2::boolean THEN 1 ELSE 0 END, 0, $3, NOW(), NOW())
`

type InsertDailyStatsParams struct {
	Date            pgtype.Date `db:"date" json:"date"`
	Column2         bool        `db:"column_2" json:"column_2"`
	AvgAnalysisTime *float64    `db:"avg_analysis_time" json:"avg_analysis_time"`
}

func (q *Queries) InsertDailyStats(ctx context.Context, arg InsertDailyStatsParams) error {
	_, err := q.db.Exec(ctx, insertDailyStats, arg.Date, arg.Column2, arg.AvgAnalysisTime)
	return err
}

const listRecentStats = `-- name: ListRecentStats :many
SELECT id, date, total_analyses, successful_analyses, failed_analyses, unique_domains, avg_analysis_time, created_at, updated_at FROM analysis_stats
ORDER BY date DESC
LIMIT $1
`

func (q *Queries) ListRecentStats(ctx context.Context, limit int32) ([]AnalysisStat, error) {
	rows, err := q.db.Query(ctx, listRecentStats, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnalysisStat{}
	for rows.Next() {
		var i AnalysisStat
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.TotalAnalyses,
			&i.SuccessfulAnalyses,
			&i.FailedAnalyses,
			&i.UniqueDomains,
			&i.AvgAnalysisTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUniqueDomainCount = `-- name: UpdateUniqueDomainCount :exec
UPDATE analysis_stats SET unique_domains = $2, updated_at = NOW() WHERE date = $1
`

type UpdateUniqueDomainCountParams struct {
	Date          pgtype.Date `db:"date" json:"date"`
	UniqueDomains *int32      `db:"unique_domains" json:"unique_domains"`
}

func (q *Queries) UpdateUniqueDomainCount(ctx context.Context, arg UpdateUniqueDomainCountParams) error {
	_, err := q.db.Exec(ctx, updateUniqueDomainCount, arg.Date, arg.UniqueDomains)
	return err
}

const upsertDailyStats = `-- name: UpsertDailyStats :exec
INSERT INTO analysis_stats (date, total_analyses, successful_analyses, failed_analyses, unique_domains, avg_analysis_time, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
ON CONFLICT (date) DO UPDATE SET
    total_analyses = $2,
    successful_analyses = $3,
    failed_analyses = $4,
    unique_domains = $5,
    avg_analysis_time = $6,
    updated_at = NOW()
`

type UpsertDailyStatsParams struct {
	Date               pgtype.Date `db:"date" json:"date"`
	TotalAnalyses      *int32      `db:"total_analyses" json:"total_analyses"`
	SuccessfulAnalyses *int32      `db:"successful_analyses" json:"successful_analyses"`
	FailedAnalyses     *int32      `db:"failed_analyses" json:"failed_analyses"`
	UniqueDomains      *int32      `db:"unique_domains" json:"unique_domains"`
	AvgAnalysisTime    *float64    `db:"avg_analysis_time" json:"avg_analysis_time"`
}

func (q *Queries) UpsertDailyStats(ctx context.Context, arg UpsertDailyStatsParams) error {
	_, err := q.db.Exec(ctx, upsertDailyStats,
		arg.Date,
		arg.TotalAnalyses,
		arg.SuccessfulAnalyses,
		arg.FailedAnalyses,
		arg.UniqueDomains,
		arg.AvgAnalysisTime,
	)
	return err
}
